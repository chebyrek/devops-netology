**1. Какого типа команда cd? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа.**  

команда cd встроенная, для смены директории нужно изменить внутреннее состояние оболочки (например перезаписать какую-то переменную или вроде того), внешняя утилита такого делать не сможет.  

**2. Какая альтернатива без pipe команде grep <some_string> <some_file> | wc -l? man grep поможет в ответе на этот вопрос. Ознакомьтесь с документом о других подобных некорректных вариантах использования pipe.**  

опция ```-c```  
```
grep -c <some_string> <some_file>
```  

**3. Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?**  
```
/sbin/init
```

**4. Как будет выглядеть команда, которая перенаправит вывод stderr ls на другую сессию терминала?**  
```
$ ls /root 2> /dev/pts/1
```  

**5. Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.**  
```
$ less < file > newfile
```  

**6. Получится ли вывести находясь в графическом режиме данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?**  

да, да
```
$ tty
/dev/pts/0
$ cat file > /dev/tty1
```

```
$ tty
/dev/tty1
$ test # это содержимое файла file
```
**7. Выполните команду ```bash 5>&1```. К чему она приведет? Что будет, если вы выполните ```echo netology > /proc/$$/fd/5```? Почему так происходит?  

Файловый дескриптор 5 перенаправится в stdout. На экране появится надпись netology, потому что 5 дескриптор перенаправлен в stdout, предыдущей командой.

**8. Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty? Напоминаем: по умолчанию через pipe передается только stdout команды слева от | на stdin команды справа. Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.**  

Получится, в примере получаю содержимое папок /root и /var и передаю в sed. Сочетание 'oo' должно поменяться словах 'root' и 'spool', но т.к. в sed попадает только stderr, замена происходит только в слове 'root'. Содержимое /var также выводится на экран.
```
$ bash 5>&1
$ ls /var /root 2>&1 >&5 | sed 's/oo/XXXXXX/'
/var:
ls: cannot open directory '/rXXXXXXt': Permission denied
agentx  backups  cache  crash  lib  local  lock  log  mail  opt  run  snap  spool  tmp  www
```
**9. Что выведет команда cat /proc/$$/environ? Как еще можно получить аналогичный по содержанию вывод?**  

Список переменных окружения. Можно воспользоваться командами ```printenv``` или ```env```

**10. Используя man, опишите что доступно по адресам ```/proc/<PID>/cmdline```, ```/proc/<PID>/exe```**  
```/proc/<PID>/cmdline``` содержит полную команду запуска для процесса  
```/proc/<PID>/exe``` содержит ссылку на выполняемую команду в этом процессе  

**11. Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью ```/proc/cpuinfo```**  
```
$ cat /proc/cpuinfo | grep -o -E "sse\S+\s" | sort -r
sse4_2
sse4_1
sse3
sse2
```

**12. При открытии нового окна терминала и vagrant ssh создается новая сессия и выделяется pty. Это можно подтвердить командой tty, которая упоминалась в лекции 3.2. Однако:**
```
vagrant@netology1:~$ ssh localhost 'tty'
not a tty
```
**Почитайте, почему так происходит, и как изменить поведение.**  

По умолчанию при выполнении команды по ssh не выделяется псевдо-терминал, для изменения такого поведения необходимо использовать опцию ```-t``` 
```
$ ssh -t localhost 'tty'
user@localhost's password:
/dev/pts/2
```
**13. Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись reptyr. Например, так можно перенести в screen процесс, который вы запустили по ошибке в обычной SSH-сессии.**  

Попробовал, работает

**14. ```sudo echo string > /root/new_file``` не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без sudo под вашим пользователем. Для решения данной проблемы можно использовать конструкцию ```echo string | sudo tee /root/new_file```. Узнайте что делает команда tee и почему в отличие от sudo echo команда с sudo tee будет работать**  

Команда tee направляет вывод как на stdout, так и в файлы, указаные в качестве параметров. 
Sudo echo не работает, потому что перенаправление выполняется оболочкой, а она запущена под обычными пользователем.
